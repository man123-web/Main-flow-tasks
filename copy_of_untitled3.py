# -*- coding: utf-8 -*-
"""Copy of Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xlgd4mucKj-wjeWLU1dK3ZXC2YkwoF8k

01. Write a program to calculate the sum of two numbers. Input: Two integers. Output: Single integer, their sum. Hint: Use the simple addition (+) operator.
"""

# Input: Two integers
number1 = int(input("Enter the first integer: "))
number2 = int(input("Enter the second integer: "))

# Calculate the sum
result = number1 + number2

# Output: The sum of the two numbers
print("The sum is:", result)

""" 2. Odd or Even
Objective: Determine whether a number is odd or even.
Input: A single integer.
Output: "Odd" or "Even".
Hint: Check the remainder when divided by 2 (number % 2 == 0 for even).
"""

# Input: A single integer
number = int(input("Enter an integer: "))

# Determine if the number is odd or even
if number % 2 == 0:
    print("Even")
else:
    print("Odd")

"""3. Factorial Calculation
Objective: Compute the factorial of a given number nnn (i.e., n!=n×(n−1)×⋯×1n! = n
\times (n-1) \times \dots \times 1n!=n×(n−1)×⋯×1).
Input: A single integer nnn.
Output: Integer value of n!n!n!.
Hint: Use a loop or math.factorial library.
"""

# Input: A single integer
n = int(input("Enter a non-negative integer: "))

# Initialize factorial to 1
factorial = 1

# Calculate factorial using a loop
if n < 0:
    print("Factorial is not defined for negative numbers.")
else:
    for i in range(1, n + 1):
        factorial *= i

    # Output: The factorial of n
    print(f"The factorial of {n} is: {factorial}")

"""4.Fibonacci Sequence
Objective: Generate the first nnn numbers in the Fibonacci sequence (e.g., 0, 1, 1, 2, 3,
5, ...).
Input: Integer nnn.
Output: List of nnn Fibonacci numbers.
Hint: Use a loop where F(n)=F(n−1)+F(n−2)F(n) = F(n-1) + F(n-2)F(n)=F(n−1)+F(n−2)
"""

# Input: An integer n
n = int(input("Enter the number of Fibonacci numbers to generate: "))

# Initialize the Fibonacci sequence
fibonacci_sequence = []

# Generate Fibonacci numbers
if n <= 0:
    print("Please enter a positive integer.")
elif n == 1:
    fibonacci_sequence = [0]
else:
    fibonacci_sequence = [0, 1]  # Starting values for the Fibonacci sequence
    for i in range(2, n):
        next_fib = fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2]
        fibonacci_sequence.append(next_fib)

# Output: List of n Fibonacci numbers
print("The first", n, "Fibonacci numbers are:", fibonacci_sequence)

"""5.Reverse a String
Objective: Reverse the characters in a string.
Input: A string.

"""

# Input: A string
input_string = input("Enter a string: ")

# Reverse the string
reversed_string = input_string[::-1]

# Output: The reversed string
print("Reversed string:", reversed_string)

"""6. Check
Objective: Check if a string reads the same backward as forward.
Input: A string.
Output: True or False.
Hint: Compare the string with its reversed version.
"""

# Input: A string
input_string = input("Enter a string: ")

# Remove spaces and convert to lowercase for a case-insensitive check
cleaned_string = input_string.replace(" ", "").lower()

# Check if the string is equal to its reversed version
is_palindrome = cleaned_string == cleaned_string[::-1]

# Output: True or False
print("Is the string a palindrome?", is_palindrome)

"""7.Leap Year Check
Objective: Determine whether a year is a leap year.
Input: An integer year (e.g., 2024).
Output: True if leap year, otherwise False.
Hint: A year is a leap year if divisible by 4 but not by 100 unless divisible by 400.
"""

# Input: An integer year
year = int(input("Enter a year: "))

# Check if the year is a leap year
is_leap_year = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

# Output: True if leap year, otherwise False
print("Is the year a leap year?", is_leap_year)

"""8.Armstrong Number
Objective: Check if a number equals the sum of its digits raised to the power of the
number of digits.
Input: An integer nnn.
Output: True or False.
Example: 153 is an Armstrong number because 13+53+33=1531^3 + 5^3 + 3^3 =
15313+53+33=153.
Hint: Convert to a string to calculate the length and power.
"""

# Input: An integer n
n = int(input("Enter an integer: "))

# Convert the number to a string to calculate the number of digits
str_n = str(n)
num_digits = len(str_n)

# Calculate the sum of the digits raised to the power of the number of digits
sum_of_powers = sum(int(digit) ** num_digits for digit in str_n)

# Check if the number is equal to the sum of its digits raised to the power of the number of digits
is_armstrong = (n == sum_of_powers)

# Output: True or False
print("Is the number an Armstrong number?", is_armstrong)

"""1..1. Custom Encryption-Decryption System
● Description: Develop a program that encrypts and decrypts messages using custom
encryption algorithms like substitution ciphers or matrix transformations.
● Challenges:
○ Create a robust algorithm for encryption and decryption.
○ Handle edge cases (e.g., special characters, spaces).
○ Optionally, implement multi-layer encryption.
● Skills: Algorithm design, string manipulation, and logical reasoning.
"""

import string

# Define a simple substitution cipher
def create_cipher(key):
    alphabet = string.ascii_lowercase
    cipher = {}
    for i, char in enumerate(alphabet):
        cipher[char] = key[i]
    return cipher

def encrypt(message, cipher):
    encrypted_message = []
    for char in message:
        if char.lower() in cipher:
            encrypted_char = cipher[char.lower()]
            # Preserve the case of the original character
            if char.isupper():
                encrypted_char = encrypted_char.upper()
            encrypted_message.append(encrypted_char)
        else:
            encrypted_message.append(char)  # Leave special characters unchanged
    return ''.join(encrypted_message)

def decrypt(encrypted_message, cipher):
    # Create a reverse cipher for decryption
    reverse_cipher = {v: k for k, v in cipher.items()}
    decrypted_message = []
    for char in encrypted_message:
        if char.lower() in reverse_cipher:
            decrypted_char = reverse_cipher[char.lower()]
            # Preserve the case of the original character
            if char.isupper():
                decrypted_char = decrypted_char.upper()
            decrypted_message.append(decrypted_char)
        else:
            decrypted_message.append(char)  # Leave special characters unchanged
    return ''.join(decrypted_message)

# Main program
if __name__ == "__main__":
    # Define a key for the substitution cipher
    key = "qwertyuiopasdfghjklzxcvbnm"  # Example key (must be 26 characters)

    # Create the cipher
    cipher = create_cipher(key)

    # Input message
    message = input("Enter a message to encrypt: ")

    # Encrypt the message
    encrypted_message = encrypt(message, cipher)
    print("Encrypted message:", encrypted_message)

    # Decrypt the message
    decrypted_message = decrypt(encrypted_message, cipher)
    print("Decrypted message:", decrypted_message)